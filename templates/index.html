<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SAM2 å›¾åƒåˆ†å‰²å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #f9f9f9;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .image-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .image-canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 5px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn.active {
            transform: scale(1.05);
        }

        .foreground-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .background-btn {
            background: linear-gradient(135deg, #f44336 0%, #da190b 100%);
            color: white;
        }

        .segment-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            font-weight: bold;
        }

        .download-btn {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }

        .clear-btn {
            background: linear-gradient(135deg, #9E9E9E 0%, #757575 100%);
            color: white;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .results {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .result-item {
            text-align: center;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-item img {
            max-width: 300px;
            height: auto;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .result-images {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .result-image-container {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .result-image-container h5 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }
        
        .result-image-container img {
            max-width: 400px;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .download-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .ocr-section, .translation-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            text-align: center;
        }
        
        .ocr-controls, .translation-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .language-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
            min-width: 120px;
        }
        
        .translation-result {
            margin-top: 15px;
            text-align: left;
        }
        
        .translation-content {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            color: #333;
        }

        .ocr-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .ocr-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .points-info {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .point {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 5px;
        }

        .point.foreground {
            background: #4CAF50;
        }

        .point.background {
            background: #f44336;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .result-image-container {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 15px;
        }

        .results-content {
            display: block;
        }

        .results-content.hidden {
            display: none;
        }

        .result-header:hover {
            background: #e0e0e0 !important;
        }

        .result-header h4 {
            user-select: none;
        }

        .visualization-result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .visualization-result h3 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 18px;
        }
        
        .visualization-content {
            text-align: center;
        }
        
        .visualization-content img {
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .results {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ SAM2 å›¾åƒåˆ†å‰²å·¥å…·</h1>
            <p>ä¸Šä¼ å›¾ç‰‡ï¼Œç‚¹å‡»æ·»åŠ å‰æ™¯/èƒŒæ™¯ç‚¹ï¼Œç„¶åè¿›è¡Œæ™ºèƒ½åˆ†å‰²</p>
        </div>

        <div class="main-content">
            <!-- ä¸Šä¼ åŒºåŸŸ -->
            <div class="upload-section" id="uploadSection">
                <h3>ğŸ“ ä¸Šä¼ å›¾ç‰‡</h3>
                <p>æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
                <input type="file" id="fileInput" class="file-input" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    é€‰æ‹©å›¾ç‰‡
                </button>
            </div>

            <!-- å›¾ç‰‡æ˜¾ç¤ºå’Œäº¤äº’åŒºåŸŸ -->
            <div id="imageSection" class="hidden">
                <div class="image-container">
                    <canvas id="imageCanvas" class="image-canvas"></canvas>
                </div>

                <!-- æ§åˆ¶æŒ‰é’® -->
                <div class="controls">
                    <button class="control-btn foreground-btn" id="foregroundBtn" onclick="setMode('foreground')">
                        ğŸ¯ é€‰æ‹©å‰æ™¯
                    </button>
                    <button class="control-btn background-btn" id="backgroundBtn" onclick="setMode('background')">
                        âŒ åˆ é™¤èƒŒæ™¯
                    </button>
                    <button class="control-btn segment-btn" id="segmentBtn" onclick="segmentImage()">
                        ğŸš€ å¼€å§‹åˆ†å‰²
                    </button>
                    <button class="control-btn clear-btn" onclick="clearPoints()">
                        ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰ç‚¹
                    </button>
                    <button class="control-btn" onclick="restoreOriginalImage()" style="background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%); color: white;">
                        ğŸ”„ æ¢å¤åŸå›¾
                    </button>
                </div>

                <!-- çŠ¶æ€æ˜¾ç¤º -->
                <div id="status" class="status hidden"></div>

                <!-- ç‚¹ä¿¡æ¯æ˜¾ç¤º -->
                <div id="pointsInfo" class="points-info hidden">
                    <h4>å·²æ·»åŠ çš„ç‚¹ï¼š</h4>
                    <div id="pointsDisplay"></div>
                </div>
            </div>

            <!-- ç»“æœæ˜¾ç¤º -->
            <div id="resultsSection" class="results hidden">
                <div class="result-item">
                    <div class="result-header" onclick="toggleResults()" style="cursor: pointer; padding: 15px; background: #f5f5f5; border-radius: 5px; margin-bottom: 10px; width: 100%; box-sizing: border-box;">
                        <h4 style="margin: 0; display: flex; justify-content: space-between; align-items: center;">
                            <span>åˆ†å‰²ç»“æœ</span>
                            <span id="toggleIcon">â–¼</span>
                        </h4>
                    </div>
                    <div id="resultsContent" class="results-content">
                        <p>ç½®ä¿¡åº¦: <span id="scoreDisplay">0.00</span></p>
                        <div class="result-images">
                            <div class="result-image-container">
                                <h5>1. ä»…maskéƒ¨åˆ†çš„åŸå§‹å›¾åƒï¼ˆé€æ˜èƒŒæ™¯ï¼‰</h5>
                                <img id="maskedResultImage" alt="åˆ†å‰²ç»“æœ" style="max-width: 400px; height: auto; border: 2px solid #ddd; border-radius: 8px;">
                            </div>
                            <div class="result-image-container">
                                <h5>2. Maskå›¾åƒï¼ˆä¸åŸå§‹å›¾åƒç­‰å¤§å°ï¼‰</h5>
                                <img id="maskImage" alt="æ©ç å›¾åƒ" style="max-width: 400px; height: auto; border: 2px solid #ddd; border-radius: 8px;">
                            </div>
                            <div class="result-image-container">
                                <h5>3. Maskåè½¬å›¾åƒï¼ˆä¸åŸå§‹å›¾åƒç­‰å¤§å°ï¼‰</h5>
                                <img id="invertedMaskImage" alt="æ©ç åè½¬å›¾åƒ" style="max-width: 400px; height: auto; border: 2px solid #ddd; border-radius: 8px;">
                            </div>
                        </div>
                        <div class="download-buttons">
                            <button class="control-btn download-btn" onclick="downloadMaskedImage()">
                                ğŸ’¾ ä¸‹è½½åˆ†å‰²å›¾åƒ
                            </button>
                            <button class="control-btn" onclick="downloadMask()" style="background: linear-gradient(135deg, #607D8B 0%, #455A64 100%); color: white;">
                                ğŸ­ ä¸‹è½½æ©ç 
                            </button>
                            <button class="control-btn" onclick="downloadInvertedMask()" style="background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); color: white;">
                                ğŸ”„ ä¸‹è½½åè½¬æ©ç 
                            </button>
                        </div>
                    </div>
                    
                    <!-- OCRåŠŸèƒ½ -->
                    <div class="ocr-section">
                        <h4>OCRæ–‡å­—è¯†åˆ«ä¸ç¿»è¯‘</h4>
                        <div class="ocr-controls">
                            <select id="ocrMode" class="language-select">
                                <option value="full">å…¨å›¾OCRç¿»è¯‘</option>
                                <option value="mask">éå•†å“éƒ¨åˆ†ç¿»è¯‘å¹¶æ›¿æ¢</option>
                                <!-- <option value="replace">å•†å“éƒ¨åˆ†ç¿»è¯‘ï¼Œéå•†å“éƒ¨åˆ†æ›¿æ¢</option> -->
                            </select>
                            <select id="sourceLanguage" class="language-select">
                                <option value="">é»˜è®¤ï¼ˆä¸­æ—¥è‹±ï¼‰</option>
                                <option value="Korean">éŸ©æ–‡</option>
                                <option value="Russian">ä¿„æ–‡</option>
                                <option value="Japanese">æ—¥æ–‡</option>
                                <option value="English">è‹±æ–‡</option>
                                <option value="Chinese">ä¸­æ–‡</option>
                            </select>
                            <select id="targetLanguage" class="language-select">
                                <option value="Chinese">ä¸­æ–‡</option>
                                <option value="English">è‹±æ–‡</option>
                                <option value="Japanese">æ—¥æ–‡</option>
                                <option value="Korean">éŸ©æ–‡</option>
                                <option value="French">æ³•æ–‡</option>
                                <option value="German">å¾·æ–‡</option>
                                <option value="Spanish">è¥¿ç­ç‰™æ–‡</option>
                                <option value="Russian">ä¿„æ–‡</option>
                            </select>
                            <button class="control-btn ocr-btn" onclick="performOCR()" style="background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%); color: white;">
                                ğŸ” OCRè¯†åˆ«ç¿»è¯‘
                            </button>
                        </div>
                        <div id="ocrResult" class="translation-result hidden">
                            <h5>OCRç¿»è¯‘ç»“æœï¼š</h5>
                            <div id="ocrContent" class="translation-content"></div>
                        </div>
                        <div id="visualizationResult" class="visualization-result hidden">
                            <h5>å¯è§†åŒ–ç»“æœï¼š</h5>
                            <div class="visualization-content">
                                <img id="visualizationImage" alt="OCRå¯è§†åŒ–ç»“æœ" style="max-width: 100%; height: auto;">
                            </div>
                        </div>
                        <div id="replacedImageContainer" class="result-image-container hidden">
                            <h5>æ–‡å­—æ›¿æ¢ç»“æœï¼š</h5>
                            <div style="display: flex; gap: 20px; align-items: flex-start;">
                                <!-- å¯ç¼–è¾‘çš„ç”»å¸ƒåŒºåŸŸ -->
                                <div style="flex: 2;">
                                    <canvas id="editableCanvas" style="border: 2px solid #ddd; border-radius: 8px; max-width: 400px; height: auto; cursor: crosshair; display: none; object-fit: contain;"></canvas>
                                    <img id="replacedImage" style="max-width: 400px; height: auto;" />
                                </div>
                                
                                <!-- æ–‡å­—å›¾å±‚æ§åˆ¶é¢æ¿ -->
                                <div style="flex: 1; min-width: 250px;">
                                    <div style="margin-bottom: 10px;">
                                        <button class="control-btn" onclick="enableTextEditing()" style="background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); color: white; margin-right: 5px;">
                                            âœï¸ ç¼–è¾‘æ–‡å­—
                                        </button>
                                        <button class="control-btn" onclick="generateFinalResult()" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white;">
                                            ğŸ¨ ç”Ÿæˆæœ€ç»ˆç»“æœ
                                        </button>
                                    </div>
                                    
                                    <div id="textLayersPanel" style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px; display: none;">
                                        <h6 style="margin: 0 0 10px 0;">æ–‡å­—å›¾å±‚</h6>
                                        <div id="layersContent">
                                            <p style="color: #666; text-align: center;">æš‚æ— æ–‡å­—å›¾å±‚</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- æœ€ç»ˆç»“æœ -->
                            <div id="finalResultContainer" style="display: none; text-align: center; margin-top: 20px;">
                                <h5>ğŸ‰ æœ€ç»ˆç»“æœ</h5>
                                <img id="finalResultImage" style="max-width: 600px; width: 100%; height: auto; border: 2px solid #ddd; border-radius: 8px;" />
                                <div style="margin-top: 15px;">
                                    <button class="control-btn" onclick="downloadFinalResult()" style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white;">
                                        ğŸ’¾ ä¸‹è½½å›¾ç‰‡
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    

                    
                    <!-- ç¿»è¯‘åŠŸèƒ½ -->
                    <div class="translation-section">
                        <h4>å›¾åƒç¿»è¯‘åŠŸèƒ½</h4>
                        <div class="translation-controls">
                            <select id="targetLanguageOld" class="language-select">
                                <option value="Chinese">ä¸­æ–‡</option>
                                <option value="English">è‹±æ–‡</option>
                                <option value="Japanese">æ—¥æ–‡</option>
                                <option value="Korean">éŸ©æ–‡</option>
                                <option value="French">æ³•æ–‡</option>
                                <option value="German">å¾·æ–‡</option>
                                <option value="Spanish">è¥¿ç­ç‰™æ–‡</option>
                                <option value="Russian">ä¿„æ–‡</option>
                            </select>
                            <button class="control-btn translate-btn" onclick="translateImage()" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white;">
                                ğŸŒ ç¿»è¯‘æ–‡å­—
                            </button>
                        </div>
                        <div id="translationResult" class="translation-result hidden">
                            <h5>ç¿»è¯‘ç»“æœï¼š</h5>
                            <div id="translationContent" class="translation-content"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let currentImage = null;
        let currentMode = 'foreground'; // 'foreground' æˆ– 'background'
        let points = [];
        let labels = [];
        let maskData = null;
        let originalImageData = null;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            setupFileUpload();
            setupCanvas();
        });

        // è®¾ç½®æ–‡ä»¶ä¸Šä¼ 
        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const uploadSection = document.getElementById('uploadSection');

            fileInput.addEventListener('change', handleFileSelect);

            // æ‹–æ‹½ä¸Šä¼ 
            uploadSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadSection.classList.add('dragover');
            });

            uploadSection.addEventListener('dragleave', () => {
                uploadSection.classList.remove('dragover');
            });

            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadSection.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // å¤„ç†æ–‡ä»¶
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showStatus('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                loadImage(e.target.result);
            };
            reader.readAsDataURL(file);
        }

        // åŠ è½½å›¾ç‰‡
        function loadImage(src) {
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                originalImageData = src;
                displayImage(img);
                showImageSection();
                clearPoints();
                showStatus('å›¾ç‰‡åŠ è½½æˆåŠŸï¼ç‚¹å‡»"é€‰æ‹©å‰æ™¯"æˆ–"åˆ é™¤èƒŒæ™¯"æŒ‰é’®ï¼Œç„¶ååœ¨å›¾ç‰‡ä¸Šç‚¹å‡»æ·»åŠ ç‚¹', 'success');
            };
            img.src = src;
        }

        // æ˜¾ç¤ºå›¾ç‰‡
        function displayImage(img) {
            const canvas = document.getElementById('imageCanvas');
            const ctx = canvas.getContext('2d');

            // è®¾ç½®ç”»å¸ƒå¤§å°
            const maxWidth = 800;
            const maxHeight = 600;
            let { width, height } = img;

            if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
            }

            canvas.width = width;
            canvas.height = height;

            // ç»˜åˆ¶å›¾ç‰‡
            ctx.drawImage(img, 0, 0, width, height);
            drawPoints();
        }

        // è®¾ç½®ç”»å¸ƒç‚¹å‡»äº‹ä»¶ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function setupCanvas() {
            const canvas = document.getElementById('imageCanvas');
            
            // é¼ æ ‡äº‹ä»¶
            canvas.addEventListener('click', handleCanvasClick);
            
            // è§¦æ‘¸äº‹ä»¶ï¼ˆé˜²æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…é¡µé¢æ»šåŠ¨ï¼‰
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
                handleCanvasClick(e);
            }, { passive: false });
            
            // é˜²æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸º
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', function(e) {
                e.preventDefault();
            }, { passive: false });
        }

        // å¤„ç†ç”»å¸ƒç‚¹å‡»ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function handleCanvasClick(e) {
            if (!currentImage) return;

            const canvas = document.getElementById('imageCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // è·å–åæ ‡ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶ï¼‰
            let x, y;
            let eventType = 'mouse';
            if (e.touches && e.touches.length > 0) {
                // è§¦æ‘¸äº‹ä»¶
                eventType = 'touch';
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                // é¼ æ ‡äº‹ä»¶
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }

            // è½¬æ¢åæ ‡åˆ°åŸå›¾æ¯”ä¾‹
            const scaleX = currentImage.width / canvas.width;
            const scaleY = currentImage.height / canvas.height;
            const originalX = Math.round(x * scaleX);
            const originalY = Math.round(y * scaleY);

            // è°ƒè¯•ä¿¡æ¯ï¼ˆåœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºåæ ‡ä¿¡æ¯ï¼‰
            console.log(`ğŸ“ ${eventType}äº‹ä»¶ - æ˜¾ç¤ºåæ ‡: [${Math.round(x)}, ${Math.round(y)}] -> åŸå§‹åæ ‡: [${originalX}, ${originalY}]`);
            console.log(`ğŸ“ ç¼©æ”¾æ¯”ä¾‹: scaleX=${scaleX.toFixed(3)}, scaleY=${scaleY.toFixed(3)}`);
            console.log(`ğŸ–¼ï¸ ç”»å¸ƒå°ºå¯¸: ${canvas.width}x${canvas.height}, å›¾åƒå°ºå¯¸: ${currentImage.width}x${currentImage.height}`);

            addPoint(originalX, originalY);
        }

        // æ·»åŠ ç‚¹
        function addPoint(x, y) {
            const label = currentMode === 'foreground' ? 1 : 0;
            points.push([x, y]);
            labels.push(label);

            drawPoints();
            updatePointsDisplay();
            showPointsInfo();
        }

        // ç»˜åˆ¶ç‚¹
        function drawPoints() {
            if (!currentImage) return;

            const canvas = document.getElementById('imageCanvas');
            const ctx = canvas.getContext('2d');

            // é‡æ–°ç»˜åˆ¶å›¾ç‰‡
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç‚¹
            const scaleX = canvas.width / currentImage.width;
            const scaleY = canvas.height / currentImage.height;

            points.forEach((point, index) => {
                const x = point[0] * scaleX;
                const y = point[1] * scaleY;
                const label = labels[index];

                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = label === 1 ? '#4CAF50' : '#f44336';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // æ·»åŠ æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label === 1 ? 'F' : 'B', x, y + 4);
            });
        }

        // è®¾ç½®æ¨¡å¼
        function setMode(mode) {
            currentMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('foregroundBtn').classList.toggle('active', mode === 'foreground');
            document.getElementById('backgroundBtn').classList.toggle('active', mode === 'background');
            
            // æ›´æ–°å…‰æ ‡æ ·å¼
            const canvas = document.getElementById('imageCanvas');
            if (mode === 'foreground') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        }

        // æ¸…é™¤æ‰€æœ‰ç‚¹
        function clearPoints() {
            points = [];
            labels = [];
            drawPoints();
            hidePointsInfo();
            hideResults();
        }

        // æ¢å¤åŸå›¾
        function restoreOriginalImage() {
            if (currentImage) {
                displayImage(currentImage);
                hideResults();
                showStatus('å·²æ¢å¤åŸå›¾', 'success');
            }
        }

        // æ˜¾ç¤ºå›¾ç‰‡åŒºåŸŸ
        function showImageSection() {
            document.getElementById('imageSection').classList.remove('hidden');
        }

        // æ˜¾ç¤ºç‚¹ä¿¡æ¯
        function showPointsInfo() {
            document.getElementById('pointsInfo').classList.remove('hidden');
        }

        // éšè—ç‚¹ä¿¡æ¯
        function hidePointsInfo() {
            document.getElementById('pointsInfo').classList.add('hidden');
        }

        // æ›´æ–°ç‚¹æ˜¾ç¤º
        function updatePointsDisplay() {
            const display = document.getElementById('pointsDisplay');
            display.innerHTML = '';

            points.forEach((point, index) => {
                const label = labels[index];
                const pointDiv = document.createElement('span');
                pointDiv.className = `point ${label === 1 ? 'foreground' : 'background'}`;
                pointDiv.title = `ç‚¹ ${index + 1}: (${point[0]}, ${point[1]}) - ${label === 1 ? 'å‰æ™¯' : 'èƒŒæ™¯'}`;
                display.appendChild(pointDiv);
            });
        }

        // æ˜¾ç¤ºçŠ¶æ€
        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            
            if (type === 'loading') {
                status.innerHTML = `<div class="loading-spinner"></div>${message}`;
            } else {
                status.textContent = message;
            }
            
            status.className = `status ${type}`;
            status.classList.remove('hidden');
        }

        // éšè—çŠ¶æ€
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // éšè—ç»“æœ
        function hideResults() {
            document.getElementById('resultsSection').classList.add('hidden');
        }

        // åˆ†å‰²å›¾ç‰‡
        async function segmentImage() {
            if (points.length === 0) {
                showStatus('è¯·å…ˆæ·»åŠ ä¸€äº›ç‚¹', 'error');
                return;
            }

            showStatus('æ­£åœ¨å¤„ç†å›¾ç‰‡ï¼Œè¯·ç¨å€™...', 'loading');

            try {
                const response = await fetch('/api/segment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: originalImageData,
                        points: points,
                        labels: labels
                    })
                });

                const data = await response.json();

                if (data.success) {
                    maskData = data.mask_data;
                    displayResult(data.blended, data.masked_result, data.mask, data.inverted_mask, data.score);
                    showStatus('åˆ†å‰²å®Œæˆï¼', 'success');
                } else {
                    showStatus(`åˆ†å‰²å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`ç½‘ç»œé”™è¯¯: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResult(blendedImageData, maskedResultData, maskData, invertedMaskData, score) {
            const canvas = document.getElementById('imageCanvas');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const maskedResultImage = document.getElementById('maskedResultImage');
            const maskImage = document.getElementById('maskImage');
            const invertedMaskImage = document.getElementById('invertedMaskImage');
            
            // æ›´æ–°ç”»å¸ƒæ˜¾ç¤ºåˆ†å‰²ç»“æœ
            const resultImg = new Image();
            resultImg.onload = function() {
                const ctx = canvas.getContext('2d');
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶åˆ†å‰²ç»“æœ
                ctx.drawImage(resultImg, 0, 0, canvas.width, canvas.height);
            };
            resultImg.src = `data:image/png;base64,${blendedImageData}`;
            
            // æ˜¾ç¤ºæ©ç éƒ¨åˆ†çš„åŸå›¾ï¼ˆé€æ˜èƒŒæ™¯ï¼‰
            maskedResultImage.src = `data:image/png;base64,${maskedResultData}`;
            
            // æ˜¾ç¤ºæ©ç å›¾åƒ
            maskImage.src = `data:image/png;base64,${maskData}`;
            
            // æ˜¾ç¤ºæ©ç åè½¬å›¾åƒ
            invertedMaskImage.src = `data:image/png;base64,${invertedMaskData}`;
            
            scoreDisplay.textContent = score.toFixed(3);
            
            // æ˜¾ç¤ºç»“æœåŒºåŸŸä½†é»˜è®¤æŠ˜å 
            const resultsSection = document.getElementById('resultsSection');
            const resultsContent = document.getElementById('resultsContent');
            const toggleIcon = document.getElementById('toggleIcon');
            
            resultsSection.classList.remove('hidden');
            resultsContent.style.display = 'none';  // é»˜è®¤æŠ˜å 
            toggleIcon.textContent = 'â–¼';  // æ˜¾ç¤ºå±•å¼€å›¾æ ‡
            
            // ä¿å­˜å½“å‰æ©ç ç»“æœå›¾åƒç”¨äºç¿»è¯‘
            window.currentMaskedResultData = maskedResultData;
        }

        // OCRè¯†åˆ«å¹¶ç¿»è¯‘
        async function performOCR() {
            if (!originalImageData) {
                showStatus('æ²¡æœ‰å¯å¤„ç†çš„å›¾åƒ', 'error');
                return;
            }

            const ocrMode = document.getElementById('ocrMode').value;
            const targetLanguage = document.getElementById('targetLanguage').value;
            const sourceLanguage = document.getElementById('sourceLanguage').value;
            const ocrResult = document.getElementById('ocrResult');
            const ocrContent = document.getElementById('ocrContent');
            const replacedImageContainer = document.getElementById('replacedImageContainer');
            const replacedImage = document.getElementById('replacedImage');
            const visualizationResult = document.getElementById('visualizationResult');
            const visualizationImage = document.getElementById('visualizationImage');

            try {
                showStatus('æ­£åœ¨è¿›è¡ŒOCRè¯†åˆ«...', 'loading');
                
                let requestData = {
                    image_base64: originalImageData,
                    target_language: targetLanguage,
                    source_language: sourceLanguage  // æ·»åŠ åŸè¯­è¨€å‚æ•°
                };

                let endpoint = '/api/ocr_translate';
                
                if (ocrMode === 'mask') {
                    if (!maskData) {
                        showStatus('è¯·å…ˆè¿›è¡Œå›¾åƒåˆ†å‰²', 'error');
                        return;
                    }
                    requestData.mask_data = maskData;
                    requestData.ocr_mode = 'mask';
                } else if (ocrMode === 'replace') {
                    if (!maskData) {
                        showStatus('è¯·å…ˆè¿›è¡Œå›¾åƒåˆ†å‰²', 'error');
                        return;
                    }
                    requestData.mask_data = maskData;
                    endpoint = '/api/ocr_replace';
                } else {
                    requestData.ocr_mode = 'full';
                }

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });

                const data = await response.json();

                if (data.success) {
                    ocrContent.innerHTML = data.translation.replace(/\n/g, '<br>');
                    ocrResult.classList.remove('hidden');
                    
                    if ((ocrMode === 'replace' || ocrMode === 'mask') && data.replaced_image) {
                        replacedImage.src = 'data:image/jpeg;base64,' + data.replaced_image;
                        replacedImageContainer.classList.remove('hidden');
                        
                        // ä¿å­˜æ–‡å­—å›¾å±‚ä¿¡æ¯ç”¨äºç¼–è¾‘
                        console.log('OCRå“åº”æ•°æ®:', data);
                        console.log('data.text_layers:', data.text_layers);
                        console.log('data.processed_image:', data.processed_image ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                        
                        if (data.text_layers && Array.isArray(data.text_layers) && data.text_layers.length > 0) {
                            window.textLayers = data.text_layers;
                            window.processedImage = 'data:image/jpeg;base64,' + data.processed_image;
                            console.log('æ–‡å­—å›¾å±‚å·²ä¿å­˜ï¼Œæ•°é‡:', window.textLayers.length);
                            console.log('æ–‡å­—å›¾å±‚è¯¦æƒ…:', window.textLayers);
                            
                            // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
                            window.textLayers.forEach((layer, index) => {
                                console.log(`å›¾å±‚ ${index}:`, {
                                    id: layer.id,
                                    original_text: layer.original_text,
                                    translated_text: layer.translated_text,
                                    text_color: layer.text_color,
                                    font_size: layer.font_size,
                                    font_family: layer.font_family,
                                    spacing: layer.spacing,
                                    is_in_product: layer.is_in_product
                                });
                            });
                        } else {
                            console.log('æ²¡æœ‰æ”¶åˆ°æœ‰æ•ˆçš„æ–‡å­—å›¾å±‚æ•°æ®');
                            window.textLayers = null;
                            window.processedImage = null;
                        }
                    } else {
                        replacedImageContainer.classList.add('hidden');
                    }

                    if (data.visualization) {
                        if (visualizationImage) {
                            visualizationImage.src = 'data:image/jpeg;base64,' + data.visualization;
                            visualizationResult.classList.remove('hidden');
                        }
                    } else {
                        visualizationResult.classList.add('hidden');
                    }
                    
                    showStatus('OCRè¯†åˆ«ç¿»è¯‘å®Œæˆï¼', 'success');
                } else {
                    showStatus(`OCRè¯†åˆ«å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('OCRé”™è¯¯:', error);
                showStatus(`OCRé”™è¯¯: ${error.message}`, 'error');
            }
        }

        // ç¿»è¯‘å›¾åƒä¸­çš„æ–‡å­—
        async function translateImage() {
            if (!window.currentMaskedResultData) {
                showStatus('æ²¡æœ‰å¯ç¿»è¯‘çš„å›¾åƒ', 'error');
                return;
            }

            const targetLanguage = document.getElementById('targetLanguageOld').value;
            const translationResult = document.getElementById('translationResult');
            const translationContent = document.getElementById('translationContent');

            try {
                showStatus('æ­£åœ¨ç¿»è¯‘...', 'loading');
                
                const response = await fetch('/api/translate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image_base64: window.currentMaskedResultData,
                        target_language: targetLanguage
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // æ›´æ–°ç¿»è¯‘æ–‡æœ¬
                    translationContent.textContent = data.translation;
                    translationResult.classList.remove('hidden');
                    
                    // å¦‚æœæœ‰æ›¿æ¢åçš„å›¾åƒï¼Œä¹Ÿæ›´æ–°å›¾åƒç»“æœ
                    if (data.replaced_image) {
                        const replacedImage = document.getElementById('replacedImage');
                        const replacedImageContainer = document.getElementById('replacedImageContainer');
                        
                        replacedImage.src = 'data:image/jpeg;base64,' + data.replaced_image;
                        replacedImageContainer.classList.remove('hidden');
                        
                        // ä¿å­˜æ–‡å­—å›¾å±‚ä¿¡æ¯ç”¨äºç¼–è¾‘
                        if (data.text_layers && Array.isArray(data.text_layers) && data.text_layers.length > 0) {
                            window.textLayers = data.text_layers;
                            window.processedImage = 'data:image/jpeg;base64,' + data.processed_image;
                            console.log('ç¿»è¯‘åæ–‡å­—å›¾å±‚å·²ä¿å­˜ï¼Œæ•°é‡:', window.textLayers.length);
                        }
                    }
                    
                    showStatus('ç¿»è¯‘å®Œæˆï¼', 'success');
                } else {
                    showStatus(`ç¿»è¯‘å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('ç¿»è¯‘é”™è¯¯:', error);
                showStatus(`ç¿»è¯‘é”™è¯¯: ${error.message}`, 'error');
            }
        }

        // ä¸‹è½½åˆ†å‰²å›¾åƒï¼ˆé€æ˜èƒŒæ™¯ï¼‰
        async function downloadMaskedImage() {
            if (!maskData || !originalImageData) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„ç»“æœ', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨å‡†å¤‡ä¸‹è½½...', 'loading');
                
                console.log('å‘é€ä¸‹è½½è¯·æ±‚...');
                const response = await fetch('/api/download_masked_image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mask_data: maskData,
                        image: originalImageData
                    })
                });

                console.log('å“åº”çŠ¶æ€:', response.status);
                console.log('å“åº”å¤´:', response.headers);

                if (response.ok) {
                    const blob = await response.blob();
                    console.log('Blob å¤§å°:', blob.size);
                    
                    if (blob.size === 0) {
                        showStatus('ä¸‹è½½å¤±è´¥: æ–‡ä»¶ä¸ºç©º', 'error');
                        return;
                    }
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'masked_image.png';
                    a.style.display = 'none';
                    
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                    
                    showStatus('ä¸‹è½½å®Œæˆï¼', 'success');
                } else {
                    let errorMessage = 'ä¸‹è½½å¤±è´¥';
                    try {
                        const errorText = await response.text();
                        console.log('é”™è¯¯å“åº”:', errorText);
                        const data = JSON.parse(errorText);
                        errorMessage = data.error || errorMessage;
                    } catch {
                        errorMessage = 'ä¸‹è½½å¤±è´¥: æœåŠ¡å™¨é”™è¯¯';
                    }
                    showStatus(errorMessage, 'error');
                }
            } catch (error) {
                console.error('ä¸‹è½½é”™è¯¯:', error);
                showStatus(`ä¸‹è½½é”™è¯¯: ${error.message}`, 'error');
            }
        }

        // ä¸‹è½½æ©ç 
        async function downloadMask() {
            if (!maskData) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„æ©ç ', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨å‡†å¤‡ä¸‹è½½æ©ç ...', 'loading');
                
                const response = await fetch('/api/download_mask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mask_data: maskData
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    
                    if (blob.size === 0) {
                        showStatus('ä¸‹è½½å¤±è´¥: æ©ç æ–‡ä»¶ä¸ºç©º', 'error');
                        return;
                    }
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'mask.png';
                    a.style.display = 'none';
                    
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                    
                    showStatus('æ©ç ä¸‹è½½å®Œæˆï¼', 'success');
                } else {
                    let errorMessage = 'æ©ç ä¸‹è½½å¤±è´¥';
                    try {
                        const errorText = await response.text();
                        const data = JSON.parse(errorText);
                        errorMessage = data.error || errorMessage;
                    } catch {
                        errorMessage = 'æ©ç ä¸‹è½½å¤±è´¥: æœåŠ¡å™¨é”™è¯¯';
                    }
                    showStatus(errorMessage, 'error');
                }
            } catch (error) {
                console.error('æ©ç ä¸‹è½½é”™è¯¯:', error);
                showStatus(`æ©ç ä¸‹è½½é”™è¯¯: ${error.message}`, 'error');
            }
        }

        // ä¸‹è½½åè½¬æ©ç 
        async function downloadInvertedMask() {
            if (!maskData) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„åè½¬æ©ç ', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨å‡†å¤‡ä¸‹è½½åè½¬æ©ç ...', 'loading');
                
                const response = await fetch('/api/download_inverted_mask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mask_data: maskData
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    
                    if (blob.size === 0) {
                        showStatus('ä¸‹è½½å¤±è´¥: åè½¬æ©ç æ–‡ä»¶ä¸ºç©º', 'error');
                        return;
                    }
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'inverted_mask.png';
                    a.style.display = 'none';
                    
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                    
                    showStatus('åè½¬æ©ç ä¸‹è½½å®Œæˆï¼', 'success');
                } else {
                    let errorMessage = 'åè½¬æ©ç ä¸‹è½½å¤±è´¥';
                    try {
                        const errorText = await response.text();
                        const data = JSON.parse(errorText);
                        errorMessage = data.error || errorMessage;
                    } catch {
                        errorMessage = 'åè½¬æ©ç ä¸‹è½½å¤±è´¥: æœåŠ¡å™¨é”™è¯¯';
                    }
                    showStatus(errorMessage, 'error');
                }
            } catch (error) {
                console.error('åè½¬æ©ç ä¸‹è½½é”™è¯¯:', error);
                showStatus(`åè½¬æ©ç ä¸‹è½½é”™è¯¯: ${error.message}`, 'error');
            }
        }

        // åˆ‡æ¢ç»“æœæ˜¾ç¤ºçš„æŠ˜å /å±•å¼€
        function toggleResults() {
            const resultsContent = document.getElementById('resultsContent');
            const toggleIcon = document.getElementById('toggleIcon');

            if (resultsContent.style.display === 'none') {
                resultsContent.style.display = 'block';
                toggleIcon.textContent = 'â–²';
            } else {
                resultsContent.style.display = 'none';
                toggleIcon.textContent = 'â–¼';
            }
        }

        // ========== æ–‡å­—å›¾å±‚ç¼–è¾‘åŠŸèƒ½ ==========
        
        // å…¨å±€å˜é‡
        let textLayers = [];
        let processedImage = null;
        let textEditorCanvas = null;
        let textEditorCtx = null;
        let selectedLayer = null;
        let isDragging = false;
        let dragStart = null;



        // ========== æ–‡å­—æ›¿æ¢ç»“æœäº¤äº’å¼ç¼–è¾‘åŠŸèƒ½ ==========
        
        // å…¨å±€å˜é‡
        let editableCanvas = null;
        let editableCtx = null;
        let isResizing = false;     // æ–°å¢ï¼šæ˜¯å¦æ­£åœ¨ç¼©æ”¾
        let resizeHandle = null;    // æ–°å¢ï¼šå½“å‰æ‹–æ‹½çš„ç¼©æ”¾æ§åˆ¶ç‚¹

        // å¯ç”¨æ–‡å­—ç¼–è¾‘
        function enableTextEditing() {
            // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ç¼–è¾‘çŠ¶æ€
            const editableCanvas = document.getElementById('editableCanvas');
            const replacedImage = document.getElementById('replacedImage');
            
            if (editableCanvas.style.display === 'block' && replacedImage.style.display === 'none') {
                console.log('å·²ç»åœ¨ç¼–è¾‘çŠ¶æ€ï¼Œå¿½ç•¥é‡å¤ç‚¹å‡»');
                return;
            }
            
            console.log('å¯ç”¨æ–‡å­—ç¼–è¾‘ï¼Œæ£€æŸ¥æ•°æ®:');
            console.log('window.textLayers:', window.textLayers);
            console.log('window.processedImage:', window.processedImage ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            
            if (!window.textLayers || !window.processedImage) {
                showStatus('æ²¡æœ‰å¯ç¼–è¾‘çš„æ–‡å­—å›¾å±‚', 'error');
                return;
            }

            /* ğŸ‘‰ åœ¨éšè—åŸå›¾ä¹‹å‰å°±æŠŠæ˜¾ç¤ºå°ºå¯¸è®°å½•ä¸‹æ¥ */
            const originalImg = document.getElementById('replacedImage');
            const displayWidth = originalImg.offsetWidth || originalImg.naturalWidth;
            const displayHeight = originalImg.offsetHeight || originalImg.naturalHeight;

            // åˆå§‹åŒ–ç”»å¸ƒï¼Œä¼ å…¥åˆšæ‹¿åˆ°çš„å°ºå¯¸
            initEditableCanvas(displayWidth, displayHeight);

            // å†æŠŠåŸå›¾éšè—
            originalImg.style.display = 'none';
            document.getElementById('editableCanvas').style.display = 'block';
            document.getElementById('textLayersPanel').style.display = 'block';

            // æ›´æ–°å›¾å±‚é¢æ¿
            updateLayersPanel();
            
            showStatus('æ–‡å­—ç¼–è¾‘å·²å¯ç”¨ï¼Œå¯ä»¥æ‹–æ‹½è°ƒæ•´ä½ç½®', 'success');
        }

        // åˆå§‹åŒ–å¯ç¼–è¾‘ç”»å¸ƒ
        function initEditableCanvas(displayWidth, displayHeight) {
            editableCanvas = document.getElementById('editableCanvas');
            editableCtx = editableCanvas.getContext('2d');

            /* ğŸ‘‰ è¿™é‡Œç›´æ¥ç”¨ enableTextEditing ä¼ è¿›æ¥çš„å°ºå¯¸ */
            editableCanvas.width = displayWidth;
            editableCanvas.height = displayHeight;
            editableCanvas.style.width = displayWidth + 'px';
            editableCanvas.style.height = displayHeight + 'px';
            
            // è®¾ç½®Canvasçš„åƒç´ å¯†åº¦ï¼Œæé«˜å­—ä½“æ¸…æ™°åº¦
            const devicePixelRatio = window.devicePixelRatio || 1;
            const rect = editableCanvas.getBoundingClientRect();
            
            // è®¾ç½®Canvasçš„å®é™…å°ºå¯¸ä¸ºæ˜¾ç¤ºå°ºå¯¸çš„2å€ï¼Œæé«˜æ¸…æ™°åº¦
            editableCanvas.width = displayWidth * 2;
            editableCanvas.height = displayHeight * 2;
            editableCanvas.style.width = displayWidth + 'px';
            editableCanvas.style.height = displayHeight + 'px';
            
            // ç¼©æ”¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é…æ˜¾ç¤ºå°ºå¯¸
            editableCtx.scale(2, 2);

            const bgImg = new Image();
            bgImg.onload = () => {
                console.log('  åˆå§‹åŒ–èƒŒæ™¯å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå°ºå¯¸:', bgImg.width, 'x', bgImg.height);
                editableCtx.drawImage(bgImg, 0, 0, displayWidth, displayHeight);
                drawTextLayersOnCanvas();       // æ–‡å­—è¿™æ—¶å°±èƒ½æ­£ç¡®ç”»å‡ºæ¥
                addEditableCanvasEventListeners();
            };
            bgImg.onerror = () => {
                console.error('âŒ åˆå§‹åŒ–èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥');
            };
            const imageSrc = window.processedImage || document.getElementById('replacedImage').src;
            console.log('  åˆå§‹åŒ–ä½¿ç”¨å›¾ç‰‡æº:', imageSrc ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            bgImg.src = imageSrc;
        }

        // åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶æ–‡å­—å›¾å±‚
        function drawTextLayersOnCanvas() {
            if (!editableCtx || !window.textLayers) return;
            
            // è·å–åŸå›¾ç‰‡çš„å®é™…å°ºå¯¸å’Œæ˜¾ç¤ºå°ºå¯¸
            const originalImg = document.getElementById('replacedImage');
            const naturalWidth = originalImg.naturalWidth;
            const naturalHeight = originalImg.naturalHeight;
            const displayWidth = editableCanvas.width / 2;  // ç”±äºCanvasç¼©æ”¾äº†2å€ï¼Œéœ€è¦é™¤ä»¥2
            const displayHeight = editableCanvas.height / 2;
            
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            console.log(`ğŸ” ç»˜åˆ¶æ–‡å­—å›¾å±‚ - åŸå§‹å°ºå¯¸: ${naturalWidth}x${naturalHeight}, æ˜¾ç¤ºå°ºå¯¸: ${displayWidth}x${displayHeight}`);
            console.log(`ğŸ” ç¼©æ”¾æ¯”ä¾‹: scaleX=${scaleX.toFixed(3)}, scaleY=${scaleY.toFixed(3)}`);
            
            window.textLayers.forEach(layer => {
                if (!layer.visible) return;
                
                const [x1, y1, x2, y2] = layer.box;
                // ç¼©æ”¾åæ ‡åˆ°æ˜¾ç¤ºå°ºå¯¸
                const scaledX1 = x1 * scaleX;
                const scaledY1 = y1 * scaleY;
                const scaledX2 = x2 * scaleX;
                const scaledY2 = y2 * scaleY;
                
                console.log(`ğŸ” å›¾å±‚ ${layer.id}: åŸå§‹åæ ‡ [${x1}, ${y1}, ${x2}, ${y2}] -> æ˜¾ç¤ºåæ ‡ [${scaledX1.toFixed(1)}, ${scaledY1.toFixed(1)}, ${scaledX2.toFixed(1)}, ${scaledY2.toFixed(1)}]`);
                
                const centerX = (scaledX1 + scaledX2) / 2;
                const centerY = (scaledY1 + scaledY2) / 2;
                
                // è®¾ç½®æ–‡å­—æ ·å¼
                const r = layer.text_color[0];
                const g = layer.text_color[1];
                const b = layer.text_color[2];
                editableCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                // ä½¿ç”¨å›¾å±‚ä¸­çš„å­—ä½“ç±»å‹å’Œå¤§å°
                const fontFamily = layer.font_family || 'Microsoft YaHei';
                const fontSize = layer.font_size * Math.min(scaleX, scaleY);
                
                // è®¾ç½®å­—ä½“æ¸²æŸ“ä¼˜åŒ–
                editableCtx.font = `${fontSize}px "${fontFamily}", "SimHei", "Arial"`;
                editableCtx.textAlign = 'center';
                editableCtx.textBaseline = 'middle';
                
                // å¯ç”¨å­—ä½“å¹³æ»‘å’ŒæŠ—é”¯é½¿
                editableCtx.imageSmoothingEnabled = true;
                editableCtx.imageSmoothingQuality = 'high';
                
                // ç»˜åˆ¶æ–‡å­—ï¼ˆæ”¯æŒæ¢è¡Œå’Œå­—é—´è·ï¼‰
                const spacing = layer.spacing || 0;
                const text = layer.translated_text || '';
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«æ¢è¡Œç¬¦
                if (text.includes('\n')) {
                    // å¤šè¡Œæ–‡æœ¬ç»˜åˆ¶
                    const lines = text.split('\n');
                    const lineHeight = fontSize * 1.2; // è¡Œé«˜ä¸ºå­—ä½“å¤§å°çš„1.2å€
                    const totalHeight = lines.length * lineHeight;
                    const startY = centerY - totalHeight / 2 + lineHeight / 2;
                    
                    lines.forEach((line, lineIndex) => {
                        if (line.trim() === '') return; // è·³è¿‡ç©ºè¡Œ
                        
                        if (spacing > 0 && line.length > 1) {
                            // è®¡ç®—æ€»å®½åº¦ï¼ˆåŒ…æ‹¬å­—é—´è·ï¼‰
                            const totalWidth = line.length * fontSize + (line.length - 1) * spacing * Math.min(scaleX, scaleY);
                            const startX = centerX - totalWidth / 2;
                            
                            for (let i = 0; i < line.length; i++) {
                                const charX = startX + i * (fontSize + spacing * Math.min(scaleX, scaleY));
                                const lineY = startY + lineIndex * lineHeight;
                                editableCtx.fillText(line[i], charX, lineY);
                            }
                        } else {
                            // å•ä¸ªå­—ç¬¦æˆ–æ­£å¸¸å­—é—´è·çš„æƒ…å†µ
                            const lineY = startY + lineIndex * lineHeight;
                            editableCtx.fillText(line, centerX, lineY);
                        }
                    });
                } else {
                    // å•è¡Œæ–‡æœ¬ç»˜åˆ¶
                    if (spacing > 0 && text.length > 1) {
                        // è®¡ç®—æ€»å®½åº¦ï¼ˆåŒ…æ‹¬å­—é—´è·ï¼‰
                        const totalWidth = text.length * fontSize + (text.length - 1) * spacing * Math.min(scaleX, scaleY);
                        const startX = centerX - totalWidth / 2;
                        
                        for (let i = 0; i < text.length; i++) {
                            const charX = startX + i * (fontSize + spacing * Math.min(scaleX, scaleY));
                            editableCtx.fillText(text[i], charX, centerY);
                        }
                    } else {
                        // å•ä¸ªå­—ç¬¦æˆ–æ­£å¸¸å­—é—´è·çš„æƒ…å†µ
                        editableCtx.fillText(text, centerX, centerY);
                    }
                }
                
                // å¦‚æœæ˜¯é€‰ä¸­çš„å›¾å±‚ï¼Œç»˜åˆ¶è¾¹æ¡†å’Œç¼©æ”¾æ§åˆ¶ç‚¹
                if (layer.id === selectedLayer) {
                    editableCtx.strokeStyle = '#007AFF';
                    editableCtx.lineWidth = 2;
                    editableCtx.strokeRect(scaledX1, scaledY1, scaledX2 - scaledX1, scaledY2 - scaledY1);
                    
                    // ç»˜åˆ¶ç¼©æ”¾æ§åˆ¶ç‚¹
                    drawResizeHandles(scaledX1, scaledY1, scaledX2, scaledY2);
                }
            });
        }
        
        // ç»˜åˆ¶ç¼©æ”¾æ§åˆ¶ç‚¹ - åªæ˜¾ç¤ºå››ä¸ªè§’çš„æ§åˆ¶ç‚¹
        function drawResizeHandles(x1, y1, x2, y2) {
            const handleSize = 6;
            const handles = [
                { x: x1, y: y1, cursor: 'nw-resize', name: 'top-left' },
                { x: x2, y: y1, cursor: 'ne-resize', name: 'top-right' },
                { x: x2, y: y2, cursor: 'se-resize', name: 'bottom-right' },
                { x: x1, y: y2, cursor: 'sw-resize', name: 'bottom-left' }
            ];
            
            handles.forEach(handle => {
                editableCtx.fillStyle = '#007AFF';
                editableCtx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                editableCtx.strokeStyle = '#FFFFFF';
                editableCtx.lineWidth = 1;
                editableCtx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            });
        }

        // æ·»åŠ ç”»å¸ƒäº‹ä»¶ç›‘å¬å™¨ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function addEditableCanvasEventListeners() {
            // é¼ æ ‡äº‹ä»¶
            editableCanvas.addEventListener('mousedown', handleEditableCanvasMouseDown);
            editableCanvas.addEventListener('mousemove', handleEditableCanvasMouseMove);
            editableCanvas.addEventListener('mouseup', handleEditableCanvasMouseUp);
            editableCanvas.addEventListener('mouseleave', handleEditableCanvasMouseUp);
            editableCanvas.addEventListener('mousemove', handleEditableCanvasMouseHover);
            
            // è§¦æ‘¸äº‹ä»¶
            editableCanvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                handleEditableCanvasTouchStart(e);
            }, { passive: false });
            
            editableCanvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                handleEditableCanvasTouchMove(e);
            }, { passive: false });
            
            editableCanvas.addEventListener('touchend', function(e) {
                e.preventDefault();
                handleEditableCanvasTouchEnd(e);
            }, { passive: false });
        }
        
        // å¤„ç†é¼ æ ‡æ‚¬åœï¼Œæ”¹å˜å…‰æ ‡æ ·å¼ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function handleEditableCanvasMouseHover(e) {
            if (isDragging || isResizing) return;
            
            const rect = editableCanvas.getBoundingClientRect();
            let x, y;
            
            // è·å–åæ ‡ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶ï¼‰
            if (e.touches && e.touches.length > 0) {
                // è§¦æ‘¸äº‹ä»¶
                x = (e.touches[0].clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.touches[0].clientY - rect.top) * (editableCanvas.height / rect.height);
            } else {
                // é¼ æ ‡äº‹ä»¶
                x = (e.clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.clientY - rect.top) * (editableCanvas.height / rect.height);
            }
            
            // è·å–ç¼©æ”¾æ¯”ä¾‹
            const originalImg = document.getElementById('replacedImage');
            const naturalWidth = originalImg.naturalWidth;
            const naturalHeight = originalImg.naturalHeight;
            const displayWidth = editableCanvas.width;
            const displayHeight = editableCanvas.height;
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨ç¼©æ”¾æ§åˆ¶ç‚¹ä¸Š
            if (selectedLayer) {
                const layer = window.textLayers.find(l => l.id === selectedLayer);
                if (layer) {
                    const [x1, y1, x2, y2] = layer.box;
                    const scaledX1 = x1 * scaleX;
                    const scaledY1 = y1 * scaleY;
                    const scaledX2 = x2 * scaleX;
                    const scaledY2 = y2 * scaleY;
                    
                    const handle = getResizeHandleAt(x, y, scaledX1, scaledY1, scaledX2, scaledY2);
                    if (handle) {
                                            const cursorMap = {
                        'top-left': 'nw-resize',
                        'top-right': 'ne-resize',
                        'bottom-right': 'se-resize',
                        'bottom-left': 'sw-resize'
                    };
                        editableCanvas.style.cursor = cursorMap[handle] || 'default';
                        return;
                    }
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨å›¾å±‚ä¸Š
            const hoveredLayer = window.textLayers.find(layer => {
                const [x1, y1, x2, y2] = layer.box;
                const scaledX1 = x1 * scaleX;
                const scaledY1 = y1 * scaleY;
                const scaledX2 = x2 * scaleX;
                const scaledY2 = y2 * scaleY;
                return x >= scaledX1 && x <= scaledX2 && y >= scaledY1 && y <= scaledY2;
            });
            
            if (hoveredLayer) {
                editableCanvas.style.cursor = 'move';
            } else {
                editableCanvas.style.cursor = 'default';
            }
        }

        // å¤„ç†ç”»å¸ƒé¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function handleEditableCanvasMouseDown(e) {
            const rect = editableCanvas.getBoundingClientRect();
            let x, y;
            
            // è·å–åæ ‡ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶ï¼‰
            if (e.touches && e.touches.length > 0) {
                // è§¦æ‘¸äº‹ä»¶
                x = (e.touches[0].clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.touches[0].clientY - rect.top) * (editableCanvas.height / rect.height);
            } else {
                // é¼ æ ‡äº‹ä»¶
                x = (e.clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.clientY - rect.top) * (editableCanvas.height / rect.height);
            }
            
            // è·å–ç¼©æ”¾æ¯”ä¾‹
            const originalImg = document.getElementById('replacedImage');
            const naturalWidth = originalImg.naturalWidth;
            const naturalHeight = originalImg.naturalHeight;
            const displayWidth = editableCanvas.width;  // ä½¿ç”¨ç”»å¸ƒçš„å®é™…å°ºå¯¸
            const displayHeight = editableCanvas.height;
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç¼©æ”¾æ§åˆ¶ç‚¹
            if (selectedLayer) {
                const layer = window.textLayers.find(l => l.id === selectedLayer);
                if (layer) {
                    const [x1, y1, x2, y2] = layer.box;
                    const scaledX1 = x1 * scaleX;
                    const scaledY1 = y1 * scaleY;
                    const scaledX2 = x2 * scaleX;
                    const scaledY2 = y2 * scaleY;
                    
                    const clickedHandle = getResizeHandleAt(x, y, scaledX1, scaledY1, scaledX2, scaledY2);
                    if (clickedHandle) {
                        isResizing = true;
                        resizeHandle = clickedHandle;
                        dragStart = { x, y };
                        return;
                    }
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å›¾å±‚
            const clickedLayer = window.textLayers.find(layer => {
                const [x1, y1, x2, y2] = layer.box;
                const scaledX1 = x1 * scaleX;
                const scaledY1 = y1 * scaleY;
                const scaledX2 = x2 * scaleX;
                const scaledY2 = y2 * scaleY;
                return x >= scaledX1 && x <= scaledX2 && y >= scaledY1 && y <= scaledY2;
            });
            
            if (clickedLayer) {
                // ç¡®ä¿æœ€å¤šåªèƒ½é€‰ä¸­ä¸€ä¸ªæ–‡å­—æ¡†ï¼Œè‡ªåŠ¨å–æ¶ˆå…¶ä»–é€‰ä¸­
                selectedLayer = clickedLayer.id;
                isDragging = true;
                isResizing = false;
                resizeHandle = null;
                dragStart = { x, y };
                redrawCanvas(); // ä½¿ç”¨redrawCanvasç¡®ä¿æ­£ç¡®é‡ç»˜
            } else {
                // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œè‡ªåŠ¨å–æ¶ˆé€‰ä¸­
                selectedLayer = null;
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                redrawCanvas();
            }
        }
        
        // æ£€æµ‹ç‚¹å‡»çš„ç¼©æ”¾æ§åˆ¶ç‚¹ - åªæ£€æµ‹å››ä¸ªè§’çš„æ§åˆ¶ç‚¹
        function getResizeHandleAt(x, y, x1, y1, x2, y2) {
            const handleSize = 6;
            const handles = [
                { x: x1, y: y1, name: 'top-left' },
                { x: x2, y: y1, name: 'top-right' },
                { x: x2, y: y2, name: 'bottom-right' },
                { x: x1, y: y2, name: 'bottom-left' }
            ];
            
            for (const handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle.name;
                }
            }
            return null;
        }

        // å¤„ç†ç”»å¸ƒé¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼‰
        function handleEditableCanvasMouseMove(e) {
            if (!isDragging && !isResizing) return;
            if (!dragStart || !selectedLayer) return;
            
            const rect = editableCanvas.getBoundingClientRect();
            let x, y;
            
            // è·å–åæ ‡ï¼ˆæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶ï¼‰
            if (e.touches && e.touches.length > 0) {
                // è§¦æ‘¸äº‹ä»¶
                x = (e.touches[0].clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.touches[0].clientY - rect.top) * (editableCanvas.height / rect.height);
            } else {
                // é¼ æ ‡äº‹ä»¶
                x = (e.clientX - rect.left) * (editableCanvas.width / rect.width);
                y = (e.clientY - rect.top) * (editableCanvas.height / rect.height);
            }
            
            const deltaX = x - dragStart.x;
            const deltaY = y - dragStart.y;
            
            // è·å–ç¼©æ”¾æ¯”ä¾‹
            const originalImg = document.getElementById('replacedImage');
            const naturalWidth = originalImg.naturalWidth;
            const naturalHeight = originalImg.naturalHeight;
            const displayWidth = editableCanvas.width;  // ä½¿ç”¨ç”»å¸ƒçš„å®é™…å°ºå¯¸
            const displayHeight = editableCanvas.height;
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            if (isResizing && resizeHandle) {
                // å¤„ç†ç¼©æ”¾ - åªå…è®¸æ–œè§’ç¼©æ”¾ï¼Œè¾¹æ¡†ç´§è´´æ–‡å­—
                window.textLayers = window.textLayers.map(layer => {
                    if (layer.id !== selectedLayer) return layer;
                    
                    const [x1, y1, x2, y2] = layer.box;
                    let newX1 = x1, newY1 = y1, newX2 = x2, newY2 = y2;
                    
                    const deltaX_scaled = deltaX / scaleX;
                    const deltaY_scaled = deltaY / scaleY;
                    
                    // åªå¤„ç†å››ä¸ªè§’çš„ç¼©æ”¾
                    switch (resizeHandle) {
                        case 'top-left':
                            newX1 = x1 + deltaX_scaled;
                            newY1 = y1 + deltaY_scaled;
                            break;
                        case 'top-right':
                            newX2 = x2 + deltaX_scaled;
                            newY1 = y1 + deltaY_scaled;
                            break;
                        case 'bottom-right':
                            newX2 = x2 + deltaX_scaled;
                            newY2 = y2 + deltaY_scaled;
                            break;
                        case 'bottom-left':
                            newX1 = x1 + deltaX_scaled;
                            newY2 = y2 + deltaY_scaled;
                            break;
                    }
                    
                    // ç¡®ä¿æœ€å°å°ºå¯¸
                    const minWidth = 20 / scaleX;
                    const minHeight = 20 / scaleY;
                    if (newX2 - newX1 < minWidth) {
                        if (resizeHandle.includes('left')) newX1 = newX2 - minWidth;
                        else newX2 = newX1 + minWidth;
                    }
                    if (newY2 - newY1 < minHeight) {
                        if (resizeHandle.includes('top')) newY1 = newY2 - minHeight;
                        else newY2 = newY1 + minHeight;
                    }
                    
                    // æ ¹æ®ç¼©æ”¾æ¯”ä¾‹è°ƒæ•´å­—ä½“å¤§å° - ä¿æŒæ–‡å­—ä¸è¾¹æ¡†çš„ç´§å¯†å…³ç³»
                    const originalWidth = x2 - x1;
                    const originalHeight = y2 - y1;
                    const newWidth = newX2 - newX1;
                    const newHeight = newY2 - newY1;
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆå–å®½é«˜çš„å¹³å‡å€¼ï¼‰
                    const scaleRatio = Math.sqrt((newWidth * newHeight) / (originalWidth * originalHeight));
                    const newFontSize = Math.max(8, Math.min(100, layer.font_size * scaleRatio));
                    
                    return { 
                        ...layer, 
                        box: [newX1, newY1, newX2, newY2],
                        font_size: newFontSize
                    };
                });
            } else if (isDragging) {
                // å¤„ç†æ‹–æ‹½
                window.textLayers = window.textLayers.map(layer => 
                    layer.id === selectedLayer 
                        ? { ...layer, box: [layer.box[0] + deltaX / scaleX, layer.box[1] + deltaY / scaleY, layer.box[2] + deltaX / scaleX, layer.box[3] + deltaY / scaleY] }
                        : layer
                );
            }
            
            dragStart = { x, y };
            
            // é‡ç»˜ç”»å¸ƒ
            redrawCanvas();
        }

        // å¤„ç†ç”»å¸ƒé¼ æ ‡é‡Šæ”¾äº‹ä»¶
        function handleEditableCanvasMouseUp() {
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
            dragStart = null;
        }

        // æ›´æ–°å›¾å±‚é¢æ¿
        function updateLayersPanel() {
            const layersContent = document.getElementById('layersContent');
            
            if (!window.textLayers || window.textLayers.length === 0) {
                layersContent.innerHTML = '<p style="color: #666; text-align: center;">æš‚æ— æ–‡å­—å›¾å±‚</p>';
                return;
            }
            
            layersContent.innerHTML = window.textLayers.map(layer => `
                <div style="border: 2px solid ${layer.id === selectedLayer ? '#007AFF' : '#ddd'}; padding: 10px; margin-bottom: 10px; border-radius: 5px; background: ${layer.id === selectedLayer ? '#f0f8ff' : 'white'}; cursor: pointer;" 
                     onclick="selectLayerFromSidebar('${layer.id}')">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <input type="checkbox" ${layer.visible ? 'checked' : ''} 
                               onchange="toggleLayerVisibility('${layer.id}', this.checked)" 
                               onclick="event.stopPropagation()" 
                               style="margin-right: 5px;">
                        <span style="font-size: 12px; color: #666;">${layer.original_text}</span>
                    </div>
                    <textarea rows="3" 
                              onchange="updateLayerText('${layer.id}', this.value)" 
                              oninput="updateLayerText('${layer.id}', this.value)"
                              onclick="event.stopPropagation()"
                              onfocus="event.stopPropagation()"
                              style="width: 100%; padding: 5px; margin-bottom: 5px; border: 1px solid #ddd; border-radius: 3px; resize: vertical; font-family: inherit;"
                              placeholder="è¾“å…¥ç¿»è¯‘æ–‡æœ¬ï¼Œæ”¯æŒæ¢è¡Œ">${layer.translated_text}</textarea>
                    <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 5px;">
                        <input type="color" value="#${layer.text_color[0].toString(16).padStart(2, '0')}${layer.text_color[1].toString(16).padStart(2, '0')}${layer.text_color[2].toString(16).padStart(2, '0')}" 
                               onchange="updateLayerColor('${layer.id}', this.value)" 
                               onclick="event.stopPropagation()"
                               style="width: 30px; height: 25px; border: none;">
                        <input type="number" value="${layer.font_size}" min="8" max="100" 
                               onchange="updateLayerFontSize('${layer.id}', this.value)" 
                               onclick="event.stopPropagation()"
                               onfocus="event.stopPropagation()"
                               style="width: 60px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;">
                        <input type="number" value="${layer.spacing || 0}" min="0" max="50" 
                               onchange="updateLayerSpacing('${layer.id}', this.value)" 
                               onclick="event.stopPropagation()"
                               onfocus="event.stopPropagation()"
                               style="width: 50px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;"
                               title="å­—é—´è·">
                    </div>
                    <select onchange="updateLayerFontFamily('${layer.id}', this.value)" 
                            onclick="event.stopPropagation()"
                            onfocus="event.stopPropagation()"
                            style="width: 100%; padding: 3px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;">
                        <option value="Microsoft YaHei" ${(layer.font_family || 'Microsoft YaHei') === 'Microsoft YaHei' ? 'selected' : ''}>å¾®è½¯é›…é»‘</option>
                        <option value="SimHei" ${(layer.font_family || 'Microsoft YaHei') === 'SimHei' ? 'selected' : ''}>é»‘ä½“</option>
                        <option value="Arial" ${(layer.font_family || 'Microsoft YaHei') === 'Arial' ? 'selected' : ''}>Arial</option>
                    </select>
                </div>
            `).join('');
        }

        // åˆ‡æ¢å›¾å±‚å¯è§æ€§
        function toggleLayerVisibility(layerId, visible) {
            window.textLayers = window.textLayers.map(layer => 
                layer.id === layerId ? { ...layer, visible } : layer
            );
            redrawCanvas();
        }

        // æ›´æ–°å›¾å±‚æ–‡å­—ï¼ˆæ”¯æŒæ¢è¡Œï¼‰
        function updateLayerText(layerId, text) {
            console.log('ğŸ” æ›´æ–°å›¾å±‚æ–‡å­—:', layerId, text);
            
            window.textLayers = window.textLayers.map(layer => {
                if (layer.id !== layerId) return layer;
                
                // æ›´æ–°æ–‡å­—å†…å®¹
                const updatedLayer = { ...layer, translated_text: text };
                
                // å¦‚æœæ–‡å­—åŒ…å«æ¢è¡Œç¬¦ï¼Œé‡æ–°è®¡ç®—è¾¹æ¡†å¤§å°
                if (text.includes('\n')) {
                    console.log('  æ£€æµ‹åˆ°æ¢è¡Œç¬¦ï¼Œé‡æ–°è®¡ç®—è¾¹æ¡†');
                    // è¿™é‡Œå¯ä»¥è°ƒç”¨åç«¯çš„è¾¹æ¡†è®¡ç®—å‡½æ•°ï¼Œæˆ–è€…åœ¨å‰ç«¯ç®€å•å¤„ç†
                    // æš‚æ—¶ä¿æŒåŸæœ‰è¾¹æ¡†ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨è°ƒæ•´
                }
                
                return updatedLayer;
            });
            
            redrawCanvas();
        }

        // æ›´æ–°å›¾å±‚é¢œè‰²
        function updateLayerColor(layerId, color) {
            console.log('ğŸ” æ›´æ–°å›¾å±‚é¢œè‰²:', layerId, color);
            
            // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGBæ•°ç»„
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            console.log('  è½¬æ¢åçš„RGBé¢œè‰²:', [r, g, b]);
            
            window.textLayers = window.textLayers.map(layer => 
                layer.id === layerId ? { ...layer, text_color: [r, g, b] } : layer
            );
            
            console.log('  æ–‡å­—å›¾å±‚æ›´æ–°å®Œæˆï¼Œå¼€å§‹é‡ç»˜ç”»å¸ƒ');
            redrawCanvas();
        }

        // æ›´æ–°å›¾å±‚å­—ä½“å¤§å° - åŒæ­¥æ›´æ–°è¾¹æ¡†å¤§å°
        function updateLayerFontSize(layerId, size) {
            const fontSize = parseInt(size) || 20;
            window.textLayers = window.textLayers.map(layer => {
                if (layer.id !== layerId) return layer;
                
                // è®¡ç®—æ–°çš„è¾¹æ¡†å¤§å°ï¼Œä¿æŒæ–‡å­—ä¸è¾¹æ¡†çš„ç´§å¯†å…³ç³»
                const [x1, y1, x2, y2] = layer.box;
                const currentWidth = x2 - x1;
                const currentHeight = y2 - y1;
                
                // æ ¹æ®å­—ä½“å¤§å°å˜åŒ–è®¡ç®—æ–°çš„è¾¹æ¡†å°ºå¯¸
                const fontRatio = fontSize / layer.font_size;
                const newWidth = currentWidth * fontRatio;
                const newHeight = currentHeight * fontRatio;
                
                // ä¿æŒä¸­å¿ƒç‚¹ä¸å˜
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                const newX1 = centerX - newWidth / 2;
                const newY1 = centerY - newHeight / 2;
                const newX2 = centerX + newWidth / 2;
                const newY2 = centerY + newHeight / 2;
                
                return { 
                    ...layer, 
                    font_size: fontSize,
                    box: [newX1, newY1, newX2, newY2]
                };
            });
            redrawCanvas();
        }

        // æ›´æ–°å›¾å±‚å­—é—´è·
        function updateLayerSpacing(layerId, spacing) {
            const spacingValue = parseInt(spacing) || 0;
            window.textLayers = window.textLayers.map(layer => 
                layer.id === layerId ? { ...layer, spacing: spacingValue } : layer
            );
            redrawCanvas();
        }

        // ä»ä¾§æ é€‰æ‹©å›¾å±‚
        function selectLayerFromSidebar(layerId) {
            console.log('ğŸ” ä»ä¾§æ é€‰æ‹©å›¾å±‚:', layerId);
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰å·²é€‰ä¸­çš„å›¾å±‚ï¼Œä¸åšä»»ä½•æ“ä½œ
            if (selectedLayer === layerId) {
                console.log('  å›¾å±‚å·²ç»é€‰ä¸­ï¼Œè·³è¿‡é‡å¤é€‰æ‹©');
                return;
            }
            
            // æ›´æ–°é€‰ä¸­çš„å›¾å±‚
            selectedLayer = layerId;
            
            // é‡ç»˜é¢æ¿ä»¥æ›´æ–°é€‰ä¸­çŠ¶æ€
            updateLayersPanel();
            
            // é‡ç»˜ç”»å¸ƒä»¥æ˜¾ç¤ºé€‰ä¸­è¾¹æ¡†
            redrawCanvas();
        }

        // æ›´æ–°å›¾å±‚å­—ä½“ç±»å‹
        function updateLayerFontFamily(layerId, fontFamily) {
            window.textLayers = window.textLayers.map(layer => 
                layer.id === layerId ? { ...layer, font_family: fontFamily } : layer
            );
            redrawCanvas();
        }

        // é‡ç»˜ç”»å¸ƒå‡½æ•°
        function redrawCanvas() {
            if (!editableCtx) return;
            
            console.log('ğŸ” é‡ç»˜ç”»å¸ƒå¼€å§‹');
            console.log('  Canvaså°ºå¯¸:', editableCanvas.width, 'x', editableCanvas.height);
            console.log('  æ˜¾ç¤ºå°ºå¯¸:', editableCanvas.width / 2, 'x', editableCanvas.height / 2);
            
            const inpaintedImg = new Image();
            inpaintedImg.onload = function() {
                console.log('  èƒŒæ™¯å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå°ºå¯¸:', inpaintedImg.width, 'x', inpaintedImg.height);
                
                // æ¸…é™¤ç”»å¸ƒ
                editableCtx.clearRect(0, 0, editableCanvas.width, editableCanvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯å›¾ç‰‡ï¼Œè€ƒè™‘Canvasçš„2å€ç¼©æ”¾
                const displayWidth = editableCanvas.width / 2;
                const displayHeight = editableCanvas.height / 2;
                editableCtx.drawImage(inpaintedImg, 0, 0, displayWidth, displayHeight);
                
                console.log('  èƒŒæ™¯å›¾ç‰‡ç»˜åˆ¶å®Œæˆ');
                
                // ç»˜åˆ¶æ–‡å­—å›¾å±‚
                drawTextLayersOnCanvas();
            };
            inpaintedImg.onerror = function() {
                console.error('âŒ èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥');
            };
            // ä¼˜å…ˆä½¿ç”¨processedImageï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨replacedImage
            const imageSrc = window.processedImage || document.getElementById('replacedImage').src;
            console.log('  ä½¿ç”¨å›¾ç‰‡æº:', imageSrc ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            inpaintedImg.src = imageSrc;
        }

        // ç”Ÿæˆæœ€ç»ˆç»“æœ
        async function generateFinalResult() {
            if (!window.processedImage || !window.textLayers || window.textLayers.length === 0) {
                showStatus('æ²¡æœ‰å¯ç”Ÿæˆçš„å›¾ç‰‡', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨ç”Ÿæˆæœ€ç»ˆç»“æœ...', 'loading');
                
                // ä¿å­˜å½“å‰ç¼–è¾‘çŠ¶æ€
                window.currentTextLayers = JSON.parse(JSON.stringify(window.textLayers));
                
                // è·å–åŸå§‹å›¾ç‰‡å°ºå¯¸ï¼Œç”¨äºåæ ‡è½¬æ¢
                const originalImg = document.getElementById('replacedImage');
                const naturalWidth = originalImg.naturalWidth;
                const naturalHeight = originalImg.naturalHeight;
                
                // ä½¿ç”¨å½“å‰ç”»å¸ƒä¸Šçš„æ–‡å­—å›¾å±‚çŠ¶æ€ï¼ˆåŒ…æ‹¬ä½ç½®ã€å¤§å°ã€é¢œè‰²ã€å­—ä½“å¤§å°ç­‰ï¼‰
                const currentLayers = window.currentTextLayers.map(layer => {
                    // ç¡®ä¿åæ ‡æ˜¯ç›¸å¯¹äºåŸå§‹å›¾ç‰‡å°ºå¯¸çš„
                    const [x1, y1, x2, y2] = layer.box;
                    
                    // å¦‚æœåæ ‡å·²ç»æ˜¯åŸå§‹å°ºå¯¸ï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦åˆ™éœ€è¦è½¬æ¢
                    // è¿™é‡Œå‡è®¾layer.boxå·²ç»æ˜¯åŸå§‹å›¾ç‰‡çš„åæ ‡
                    const adjustedLayer = {
                        ...layer,
                        box: [x1, y1, x2, y2], // ä½¿ç”¨åŸå§‹åæ ‡
                        text_color: layer.text_color,
                        font_size: layer.font_size,
                        translated_text: layer.translated_text,
                        visible: layer.visible,
                        font_family: layer.font_family || 'Microsoft YaHei',
                        spacing: layer.spacing || 0
                    };
                    
                    console.log(`ğŸ” å›¾å±‚ ${layer.id}: åŸå§‹åæ ‡ [${x1}, ${y1}, ${x2}, ${y2}]`);
                    return adjustedLayer;
                });
                
                const response = await fetch('/api/ocr/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: window.processedImage,
                        text_layers: currentLayers
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
                    document.getElementById('finalResultImage').src = data.final_image;
                    document.getElementById('finalResultContainer').style.display = 'block';
                    
                    // éšè—ç¼–è¾‘ç•Œé¢
                    document.getElementById('editableCanvas').style.display = 'none';
                    document.getElementById('textLayersPanel').style.display = 'none';
                    document.getElementById('replacedImage').style.display = 'block';
                    
                    // é‡ç½®ç¼–è¾‘çŠ¶æ€
                    selectedLayer = null;
                    isDragging = false;
                    isResizing = false;
                    resizeHandle = null;
                    dragStart = null;
                    
                    showStatus('æœ€ç»ˆç»“æœç”ŸæˆæˆåŠŸï¼', 'success');
                } else {
                    showStatus(`ç”Ÿæˆå¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('ç”Ÿæˆæœ€ç»ˆç»“æœé”™è¯¯:', error);
                showStatus(`ç”Ÿæˆæœ€ç»ˆç»“æœé”™è¯¯: ${error.message}`, 'error');
            }
        }



        // ä¸‹è½½æœ€ç»ˆç»“æœ
        function downloadFinalResult() {
            const img = document.getElementById('finalResultImage');
            if (!img.src) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡', 'error');
                return;
            }
            
            const link = document.createElement('a');
            link.href = img.src;
            link.download = 'final_result.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showStatus('å›¾ç‰‡ä¸‹è½½å®Œæˆï¼', 'success');
        }

        // è§¦æ‘¸äº‹ä»¶å¤„ç†å‡½æ•°
        function handleEditableCanvasTouchStart(e) {
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = editableCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (editableCanvas.width / rect.width);
                const y = (touch.clientY - rect.top) * (editableCanvas.height / rect.height);
                
                // è·å–ç¼©æ”¾æ¯”ä¾‹
                const originalImg = document.getElementById('replacedImage');
                const naturalWidth = originalImg.naturalWidth;
                const naturalHeight = originalImg.naturalHeight;
                const displayWidth = editableCanvas.width;
                const displayHeight = editableCanvas.height;
                const scaleX = displayWidth / naturalWidth;
                const scaleY = displayHeight / naturalHeight;
                
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç¼©æ”¾æ§åˆ¶ç‚¹
                if (selectedLayer) {
                    const layer = window.textLayers.find(l => l.id === selectedLayer);
                    if (layer) {
                        const [x1, y1, x2, y2] = layer.box;
                        const scaledX1 = x1 * scaleX;
                        const scaledY1 = y1 * scaleY;
                        const scaledX2 = x2 * scaleX;
                        const scaledY2 = y2 * scaleY;
                        
                        const clickedHandle = getResizeHandleAt(x, y, scaledX1, scaledY1, scaledX2, scaledY2);
                        if (clickedHandle) {
                            isResizing = true;
                            resizeHandle = clickedHandle;
                            dragStart = { x, y };
                            return;
                        }
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å›¾å±‚
                const clickedLayer = window.textLayers.find(layer => {
                    const [x1, y1, x2, y2] = layer.box;
                    const scaledX1 = x1 * scaleX;
                    const scaledY1 = y1 * scaleY;
                    const scaledX2 = x2 * scaleX;
                    const scaledY2 = y2 * scaleY;
                    return x >= scaledX1 && x <= scaledX2 && y >= scaledY1 && y <= scaledY2;
                });
                
                if (clickedLayer) {
                    selectedLayer = clickedLayer.id;
                    isDragging = true;
                    isResizing = false;
                    resizeHandle = null;
                    dragStart = { x, y };
                    redrawCanvas();
                } else {
                    selectedLayer = null;
                    isDragging = false;
                    isResizing = false;
                    resizeHandle = null;
                    redrawCanvas();
                }
            }
        }

        function handleEditableCanvasTouchMove(e) {
            if (!isDragging && !isResizing) return;
            if (!dragStart || !selectedLayer) return;
            
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = editableCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (editableCanvas.width / rect.width);
                const y = (touch.clientY - rect.top) * (editableCanvas.height / rect.height);
                
                const deltaX = x - dragStart.x;
                const deltaY = y - dragStart.y;
                
                // è·å–ç¼©æ”¾æ¯”ä¾‹
                const originalImg = document.getElementById('replacedImage');
                const naturalWidth = originalImg.naturalWidth;
                const naturalHeight = originalImg.naturalHeight;
                const displayWidth = editableCanvas.width;
                const displayHeight = editableCanvas.height;
                const scaleX = displayWidth / naturalWidth;
                const scaleY = displayHeight / naturalHeight;
                
                if (isResizing && resizeHandle) {
                    const layer = window.textLayers.find(l => l.id === selectedLayer);
                    if (layer) {
                        const [x1, y1, x2, y2] = layer.box;
                        const scaledX1 = x1 * scaleX;
                        const scaledY1 = y1 * scaleY;
                        const scaledX2 = x2 * scaleX;
                        const scaledY2 = y2 * scaleY;
                        
                        let newX1 = scaledX1;
                        let newY1 = scaledY1;
                        let newX2 = scaledX2;
                        let newY2 = scaledY2;
                        
                        switch (resizeHandle) {
                            case 'top-left':
                                newX1 = scaledX1 + deltaX;
                                newY1 = scaledY1 + deltaY;
                                break;
                            case 'top-right':
                                newX2 = scaledX2 + deltaX;
                                newY1 = scaledY1 + deltaY;
                                break;
                            case 'bottom-right':
                                newX2 = scaledX2 + deltaX;
                                newY2 = scaledY2 + deltaY;
                                break;
                            case 'bottom-left':
                                newX1 = scaledX1 + deltaX;
                                newY2 = scaledY2 + deltaY;
                                break;
                        }
                        
                        // è½¬æ¢å›åŸå§‹åæ ‡
                        const originalX1 = Math.round(newX1 / scaleX);
                        const originalY1 = Math.round(newY1 / scaleY);
                        const originalX2 = Math.round(newX2 / scaleX);
                        const originalY2 = Math.round(newY2 / scaleY);
                        
                        layer.box = [originalX1, originalY1, originalX2, originalY2];
                        redrawCanvas();
                    }
                } else if (isDragging) {
                    const layer = window.textLayers.find(l => l.id === selectedLayer);
                    if (layer) {
                        const [x1, y1, x2, y2] = layer.box;
                        const scaledX1 = x1 * scaleX;
                        const scaledY1 = y1 * scaleY;
                        const scaledX2 = x2 * scaleX;
                        const scaledY2 = y2 * scaleY;
                        
                        const newX1 = scaledX1 + deltaX;
                        const newY1 = scaledY1 + deltaY;
                        const newX2 = scaledX2 + deltaX;
                        const newY2 = scaledY2 + deltaY;
                        
                        // è½¬æ¢å›åŸå§‹åæ ‡
                        const originalX1 = Math.round(newX1 / scaleX);
                        const originalY1 = Math.round(newY1 / scaleY);
                        const originalX2 = Math.round(newX2 / scaleX);
                        const originalY2 = Math.round(newY2 / scaleY);
                        
                        layer.box = [originalX1, originalY1, originalX2, originalY2];
                        redrawCanvas();
                    }
                }
                
                dragStart = { x, y };
            }
        }

        function handleEditableCanvasTouchEnd(e) {
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
            dragStart = null;
        }
    </script>
</body>
</html> 